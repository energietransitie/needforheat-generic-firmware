{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The needforheat-generic-firmware library enables you to use use an ESP32 device as a measurement device that can send measurements to a NeedForHeat server via a NeedForHeat API.</p> <p>To navigate around, follow the links in the navigation bar below to go forward or backward, or follow the links in the contents bar above to go directly to a section of interest.</p> <p></p>"},{"location":"deploying/configuring-presence-detection/","title":"Configuring presence detection","text":"<p>If your measurement device should support presence detection, for each device, after deploying the firmware to the device, you should perform additional steps:</p> <ol> <li>edit the nsv.csv file;</li> <li>generate the nvs.bin partition file</li> <li>deploy the nvs.bin partition to a specific measurement device</li> </ol>"},{"location":"deploying/configuring-presence-detection/#1-edit-the-nvscsv-file","title":"1. Edit the nvs.csv file","text":"<p>The MAC-addresses used for presence detection should be defined in the file <code>nvs.csv</code>;</p> <ul> <li>In a line that starts with <code>mac_addresses,data,string,</code>, one or more Bluetooth MAC-addresses can be defined.</li> <li>A MAC-address can be written like <code>AB:CD:EF:01:23:45</code> or <code>AB-CD-EF-01-23-45</code> and may be upper- or lower-case.</li> <li>When multiple MAC-addresses are defined, separate them with <code>;</code> without spaces.</li> <li>Make sure that the csv-file does not contain any unnecessary spaces.</li> </ul> <p>WARNING: Bluetooth MAC Addresses constitute personal data. NEVER push an nvs.csv file that contains true Bluetooth MAC addresses from (devices of) real persons to a (Public) GitHub respository.</p>"},{"location":"deploying/configuring-presence-detection/#2-generate-the-nvsbin-partition-file","title":"2. Generate the nvs.bin partition file","text":"<ol> <li>Open a comand prompt in the directory of the nvs.csv file you just edited.</li> <li>Use the command below to generate the partition:     <pre><code>python3 $IDF_PATH/components/nvs_flash/nvs_partition_generator/nvs_partition_gen.py generate nvs.csv nvs.bin 16384\n</code></pre>     &gt; Should you encounter issues you may try to replace <code>py &lt;command&gt;</code> in the above commands with:     &gt;     &gt; - <code>py &lt;command&gt;</code>      &gt; - <code>python &lt;command&gt;</code></li> </ol>"},{"location":"deploying/configuring-presence-detection/#3-deploy-the-nvsbin-partition-to-a-specific-measurement-device","title":"3. Deploy the nvs.bin partition to a specific measurement device","text":"<ol> <li>Open a comand prompt in the directory of the nvs.bin file you just generated.</li> <li>Use the command below to generate the partition:     <pre><code>python3 -m esptool --chip esp32 --baud 460800 write_flash 0x19000 nvs.bin\n</code></pre>     &gt; Should you encounter issues you may try to replace <code>py -m &lt;command&gt;</code> in the above commands with:     &gt;     &gt; - <code>py -m &lt;command&gt;</code>      &gt; - <code>python -m &lt;command&gt;</code></li> </ol>"},{"location":"deploying/device-preparation/","title":"Device preparation","text":"<p>This section describes how a device running firmware based on the needforheat-generic-firmware library should be prepared to work together with a NeedForHeat server using the NeedForHeat API.</p> <p>Currently, each device instance must be registered on a NeedForHeat server via the NeedForHeat API before the server accepts data send data to it from that device.</p>"},{"location":"deploying/device-preparation/#erase-all-persistenly-stored-data","title":"Erase all persistenly stored data","text":"<p>Unless you are 100% sure that it is safe to only upload firmware and keep other persistent memory intact, you should always first completely erase the persistent (non-volatile) memory of the device. The procedure below not only erases the firmware, but also any device activation_token, Wi-Fi provisioning data and device session_token that may reside in the persistent memory of the device and which is needed as bearer token that identifies, authenticates and authorizes the device when uploading measurement data to the server:</p> <ul> <li>Open a command prompt and enter:     <pre><code>py -m esptool erase_flash\n</code></pre></li> <li>If the port is not detected automatically, enter (while replacing <code>?</code>  with the digit found earlier):     <pre><code>py -m esptool erase_flash --port \"COM?\" \n</code></pre></li> </ul> <p>Should you encounter issues you may try to replace <code>py -m esptool</code> in the above commands with <code>python -m esptool</code> or <code>esptool.py</code></p> <p>After this command you should perform the full NeedForHeat device preparation flow below:</p> <ol> <li>Upload firmware to the ESP32 device</li> <li>Find the device name and activation_token</li> <li>Register the device on the NeedForHeat server using the NeedForHeat API</li> <li>Generating a QR-code and print the QR_code <p>For measurement devices that use the M5Stack CoreInk, this last step can be skipped, since the firmware automatically displays the QR-code on the e-ink screen of the device.</p> </li> </ol>"},{"location":"deploying/device-preparation/#step-1-upload-firmware-to-the-esp32-device","title":"Step 1: Upload firmware to the ESP32 device","text":"<ol> <li>Download the binary release for your device and extract it to a directory of your choice.</li> <li>Connect the device with a USB cable to the PC.</li> <li>If you used the device before, you shoud first erase all persistenly stored data</li> <li> <p>Open a comand prompt in the directory you chose to download and extract the binary releases in and enter the following:     <pre><code>py -m esptool --chip esp32 --baud 460800 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader.bin 0x18000 partitions.bin 0x1d000 ota_data_initial.bin 0x20000 firmware.bin  \n</code></pre></p> <p>This should automatically detect the USB port that the device is connected to. If not, you need to find the correct port: 1. Open the Device Manager (in Windows press the <code>Windows + X</code> key combination, then select Device Manager) 2. Go to View and click Show Hidden Devices.  3. Unfold <code>Ports (COM &amp; LPT)</code>. You should find the device there, named <code>USB-Serial CH340 *(COM?)</code> with <code>?</code> being a single digit.  </p> <p>If the COM port was not automatically detected, issue the following command (while replacing <code>?</code> with the digit found in the previous step):  <pre><code>py -m esptool --chip esp32 --port \"COM?\" --baud 460800 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader.bin 0x18000 partitions.bin 0x1d000 ota_data_initial.bin 0x20000 firmware.bin\n</code></pre></p> </li> </ol> <p>Should you encounter issues you may try to replace <code>py -m esptool</code> in the above commands with:</p> <ul> <li><code>python -m esptool</code>, </li> <li><code>python3 -m esptool</code> or</li> <li><code>esptool.py</code>.</li> </ul>"},{"location":"deploying/device-preparation/#step-2-generating-a-qr-code","title":"Step 2: Generating a QR-code","text":"<p>For measurement devices that use the M5Stack CoreInk, this step can be skipped, since the firmware automatically displays the QR-code on the e-ink screen of the device.&lt;</p> <p>The <code>device.name</code> and <code>device.activation_token</code> of the device should be encoded in a QR-code that visible to the subject that receives the NeedForHeat measurement device. When printed on a sticker, we recomend attaching it the back of the measurement device.</p> <p>In general, we follow Espressif's QR-code format. With a few additional conventions: we always use security and currently, support for SoftAP is not yet fully implemented nor fully documented. Watch this space for changes in the way the <code>name</code> key of the QR-code payload is used.</p> <p>The QR-code payload is a JSON string representing a dictionary with key value pairs listed in the table below.</p> <p>Payload information : </p> Key Value used Example Required ver Version of the QR code. <code>v1</code> Yes name device.name <code>NFH-0D45DF</code> Yes pop device.activation_token <code>810667973</code> Yes transport Wi-Fi provisioning transport type Either <code>softap</code> or <code>ble</code> Yes security Security during Wi-Fi provisioning Either <code>0</code> or <code>1</code> Optional; considered <code>1</code> (secure) if not available in QR-code payload password device.activation_token Password to connect with SoftAP device. Optional <p>To generate a QR-code, you can use any QR-code generator. When generating QR-codes for production use, you SHOULD use an offline QR-code gerator, such as this chrome extension offline QR-code generator, which also works in the Microsoft Edge browser. A device activation_token might constitute personal information since it is used in a process that might link personally identifiable information of subjects to measurement </p> <p>The Espressif QR-code payload is NOT a URL, so it should NOT start with <code>http://</code> nor with <code>https://</code>; the QR-code just includes a list of JSON key-value pairs).</p>"},{"location":"deploying/device-preparation/#prepare-an-existing-device","title":"Prepare an existing device","text":"<p>If you want to repurpose and existing device (e.g. use it in another home), you should:</p> <ul> <li>erase all persistently stored data on the device;</li> <li>after the value in the <code>name</code> column of the existing device entry in the database, append something like <code>-OLD</code> and click on <code>SAVE</code> (for the NeedForHeat test database, you can do this via CloudBeaver);</li> <li>proceed with regular device preparation.</li> </ul>"},{"location":"deploying/prerequisites/","title":"Prerequisites for deploying","text":""},{"location":"deploying/prerequisites/#hardware","title":"Hardware:","text":"<ul> <li>a device based on an ESP32 SoC, e.g.<ul> <li>LilyGO TTGO T7 Mini32 V1.3 ESP32 (programmable via micro-USB)</li> <li>M5Stack CoreInk (programmable via USB-C)</li> </ul> </li> <li>a matching USB cable </li> <li>a PC with a USB port</li> </ul>"},{"location":"deploying/prerequisites/#software","title":"Software:","text":"<ul> <li>Python v3.8 or above installed; make sure to select <code>Add Python &lt;version number&gt; to PATH</code> so you can use the Python commands we document below from a command prompt</li> <li>Esptool installed, the Espressif SoC serial bootloader utility</li> <li>PuTTY, a serial monitor utility (if your you are also developing, you may use the serial monitor utility in your IDE, instead)</li> <li>Some devices, such as the LilyGO TTGO T7 Mini32 V1.3 ESP32, are based on the  CH340 USB to serial converter, which may not be recognized by your OS. You may need to install a specific driver:<ul> <li>Windows driver</li> <li>Mac OSX driver (see also this additional info)</li> <li>Linux driver</li> <li>Android driver</li> </ul> </li> </ul>"},{"location":"documenting/device-info/","title":"Device info page","text":"<p>The purpose of a device info page is to inform people that encounter your measurement device what the device is doing, via a QR-code that is visible on the device. This information is not su much intended for the persons that installed your measurement device, but other people, like other household members in a residential builing, or colleagues and visitors in a utility builing. </p> <p>On a M5Stack CoreInk device, after the device was provisioned, the e-ink screen can show a QR-code and a text like \"scan for mor info\". Your device info page is shown to people that scan the QR-code, typically from their smartphone. </p> <p>The contents of the folder <code>/docs/device-info/</code> of a NeedForHeat measurement device repository can be used as the template for your device info page. </p>"},{"location":"documenting/device-info/#prerequisites","title":"Prerequisites","text":"<p>To edit and preview the device info page, you need:</p> <ul> <li>a NeedForHeat firmware repository cloned on your local machine; </li> <li>a web browser;</li> <li>a plain text editor (or your favourite IDE).</li> </ul>"},{"location":"documenting/device-info/#editing","title":"Editing","text":"<p>On your local machine, adapt the content of <code>index.html</code> to fit the needs of your measurement device type. Be sure to use the language of the people that might scan the device-info-QR-code of your measurement device.</p> <p>The default styles are: * <code>div.video-block</code> with predefined styling for (embedded videos); * <code>div.image-block</code> with predefined styling for images; * <code>div.text-block</code> with predefined styling for texts.</p> <p>If you change or add styles in the stylesheet, please make sure this is done consistently across all your device info pages.</p>"},{"location":"documenting/device-info/#deploying","title":"Deploying","text":"<p>In a future version of this repository, we plan do automate deploying device info pages to GitHub Pages. Most likely, the deployment will be to the <code>/&lt;github-repository-name&gt;/device_info/</code> folder of your GitHub Pages server. For example, the NeedForHeat Generic-Test measurement device info page will most likely be hosted at https://energietransitiewindesheim.nl/needforheat-generic-firmware/device_info/; the NeedForHeat Presence Detection measurement device info page will most likely be hosted at https://energietransitiewindesheim.nl/needforheat-presence-detector/device_info/</p> <p>Upload the contents to a webserver, like GitHub Pages. Be sure to include all files in the folder <code>/docs/device_info/</code>: not only the the file <code>index.html</code>, but also all resources referred to in this file, like images.</p> <p>The information below is deprecated and applies to member of the Research Group Energy Transition only.</p> <p>Files must be added in a feature branch in a subfolder named <code>&lt;device_type.name&gt;</code> of the GitHub Pages repository folder <code>energietransitie.github.io/&lt;measurement-campaign&gt;/info/&lt;device_type.name&gt;/</code>. Then create a Pull Request and ask @hterhofte to review and merge. After this, the device info pages are available via <code>https://energietransitiewindesheim.nl/&lt;measurement-campaign&gt;/&lt;device_type.name&gt;/info/</code>. </p> <p>Example</p> <ul> <li>The contents of the installation manual for the <code>CO2-meter-SCD4x</code> device type is stored in GitHub Pages repository folder energietransitie.github.io/brains4buildings2022/info/CO2-meter-SCD4x/. </li> <li>We manually created an edu.nl short link https://edu.nl/4pujw.</li> <li>This edu.nl short link refers to https://www.energietransitiewindesheim.nl/brains4buildings2022/info/CO2-meter-SCD4x/.</li> </ul>"},{"location":"documenting/generic-library/","title":"Generic library","text":"<p>In this section we describe how you can contribute to the documentation of the needforheat-generic-firmware library, which is based on MkDocs.</p>"},{"location":"documenting/generic-library/#prerequisites","title":"Prerequisites","text":"<p>To facilitate editing, in addition to satisfying the prerequisites for developing, you should:</p> <ul> <li>add GitHub Markdown Preview extionsion for Visual Studio</li> </ul>"},{"location":"documenting/generic-library/#previewing","title":"Previewing","text":"<p>To get a full preview of the MkDocs generated content, you should:</p> <ul> <li>Open a command prompt and enter:     <pre><code>pip install mkdocs-material\n</code></pre>     On on Windows: <code>Windows-key + S</code>, select <code>Command Prompt</code> and type     <pre><code>py -m pip install mkdocs-material\n</code></pre></li> <li>change the directory to the root folder of this project and start the server with the command     <pre><code>mkdocs serve\n</code></pre></li> <li>open a web browser on the URL indicated, usually http://127.0.0.1:8000/.</li> </ul> <p>Should you encounter issues you may try to replace <code>py -m &lt;command&gt;</code> in the above commands with:</p> <ul> <li><code>python -m &lt;command&gt;</code> </li> <li><code>python3 -m &lt;command&gt;</code></li> <li><code>&lt;command&gt;.py</code></li> </ul>"},{"location":"documenting/installation-manual/","title":"Device installation manual","text":"<p>The purpose of a device installation manual is to help the subjects of your measurement campaign to install, power and connect your your specific measurement device. </p> <p>The contents of the folder <code>/docs/installation-manual/</code> of a NeedForHeat measurement device repository can be used as a template for this. </p>"},{"location":"documenting/installation-manual/#prerequisites","title":"Prerequisites","text":"<p>To edit and preview the device installation manual, you need:</p> <ul> <li>a NeedForHeat firmware repository cloned on your local machine; </li> <li>a web browser;</li> <li>a plain text editor (or your favourite IDE).</li> </ul>"},{"location":"documenting/installation-manual/#editing","title":"Editing","text":"<p>Adapt the content of <code>index.html</code> to fit the needs of your measurement device type. Be sure to use the language of the intended audience of your NeedForHeat provisioning app. After scanning its QR-code, the device installation manual of your device type is presented to the user by your NeedForHeat provisioning app. </p> <p>The default styles are: * <code>div.video-block</code> with predefined styling for (embedded videos); * <code>div.image-block</code> with predefined styling for images; * <code>div.text-block</code> with predefined styling for texts.</p> <p>If you change or add styles in the stylesheet, please make sure this is done consistently across all your device info pages.</p>"},{"location":"documenting/installation-manual/#previewing","title":"Previewing","text":"<p>Open the file <code>preview.html</code> using a regular web browser to preview your device installation manual as shown in the NeedForHeat app. To make the preview resemble the size and aspect ratio of a smartphone screen: 1. Press the <code>Ctrl + Shift + I</code> keys (or <code>F12</code> ) on your keyboard to access the Developer Tools. 2. Press the <code>Ctrl + Shift + M</code> keys on to enter (mobile) device emulation mode.</p> <p>By default, your preview is now in 'Responsive' mode. Using the dropdown menu (above the preview), you can also select custom dimensions for specific devices, such as the iPhone 6/7/8.</p>"},{"location":"documenting/installation-manual/#deploying","title":"Deploying","text":"<p>In a future version of this repository, we plan do automate deploying device installation manual pages to GitHub Pages. Most likely, the deployment will be to the <code>/&lt;github-repository-name&gt;/installation_manual/</code> folder of your GitHub Pages server. For example, the NeedForHeat Generic-Test measurement device installation manual will most likely be hosted at https://energietransitiewindesheim.nl/needforheat-generic-firmware/installation_manual/; the NeedForHeat Presence Detection measurement device installation manual will most likely be hosted at https://energietransitiewindesheim.nl/needforheat-presence-detector/installation_manual/</p> <p>Upload the contents to a webserver, like GitHub Pages. Be sure to include all files in the folder <code>/docs/installation_manual/</code>: not only the the file <code>index.html</code>, but also all resources referred to in this file, like images.</p> <p>The information below is deprecated and applies to member of the Research Group Energy Transition only.</p> <p>For the NeedForHeat WarmteWachter app, files must be added in a feature branch in a  subfolder named <code>&lt;device_type.name&gt;</code> of the GitHub Pages repository folder energietransitie.github.io/manuals/. Then create a Pull Request and ask @hterhofte to review and merge. After this, the installation manual pages are available via <code>https://energietransitiewindesheim.nl/manuals/&lt;device_type.name&gt;/</code> for the NeedForHeat WarmteWachter app. </p> <p>Example: </p> <ul> <li>The contents of the installation manual for the <code>Generic-Test</code> device type is stored in GitHub Pages repository folder energietransitie.github.io/manuals/Presence-Detector/. </li> <li>The NeedForHeat WarmteWachter app opens the manual via https://www.energietransitiewindesheim.nl/manuals/Presence-Detector/.</li> <li>To get a preview on a regular browser, open https://www.energietransitiewindesheim.nl/manuals/Presence-Detector/preview.html.</li> </ul>"},{"location":"measuring/measuring/","title":"Measuring","text":"<p>Your measurement device can measure data for one or more properties. For each properties, your measurement device cen take multiple measurements in in time. The needforheat-generic-firmware library provides various convenience functions you can use to:</p> <ul> <li>add a value formatter</li> <li>schedule measurement tasks</li> <li>runing measurement tasks for multiple properties</li> <li>creating and timestamping a measurement</li> <li>adding a timestamped measurement to the secure upload queue</li> <li>securely upload your queued measurements</li> </ul>"},{"location":"measuring/measuring/#registering-a-measurement-property","title":"Registering a measurement property","text":"<p>Each property has its own:</p> <ul> <li>property_name</li> <li>format</li> <li>unit</li> </ul> <p>Before a NeedForHeat server accepts a property from any measurement device, the property first needs to be registered on that server.</p> <p>In a future version of the NeedForHeat API and NeedForHeat server, we may drop this requirement.</p>"},{"location":"measuring/measuring/#property-value-formatting","title":"Property value formatting","text":"<p>To format your measurement values, your firmware only needs to specify a printf format string for each property_name.</p> Example: adding a property formatter<pre><code>Measurements::Measurement::AddFormatter(\"example\", \"%d\"); // (1)!\n</code></pre> <ol> <li><code>example</code> is the property name. <code>%d</code> is the printf format string that this property uses to format its value before it is sent to the NeedForHeat server via the NeedForHeat API in a JSON string.</li> </ol>"},{"location":"measuring/measuring/#creating-and-timestamping-a-measurement","title":"Creating and timestamping a measurement","text":"<p>Before your firmware creates a measurement instance, it should have added a formatter for the measurement's property, as illustrated in the sectione Property value formatting above.</p> <p>Two ways are available in the  needforheat-generic-firmware library for your firmware to attach a timestamp to a measurement.</p>"},{"location":"measuring/measuring/#using-the-current-task-time-timestamp","title":"Using the current task time timestamp","text":"<p>If your firmware code does NOT specify a timestamp, the measurement timestamp will be set to the current task time before the measurement is uploaded securely. This is often a good default choice: all measurements of all properties that were started at the same time are guaranteed to have the same timestamp, which often makes analysis easier. </p> Example: creating a measurement with the current task time (the default)<pre><code>#include &lt;measurements.hpp&gt;\n\nint exampleValue = 1;\n\nMeasurements::Measurement exampleMeasurement(\"example\", exampleValue); // (1)!\n</code></pre> <ol> <li>Create a new measurement with property type <code>example</code> and the value <code>exampleValue</code>. Since no timestamp is provided by the firmware, the generic firmware will attach the current task time to this measuerment value before it is uploaded to a NeedForHeat server via the NeedForHeat API.</li> </ol>"},{"location":"measuring/measuring/#specifying-a-custom-timestamp","title":"Specifying a custom timestamp","text":"<p>If your firmware code specifies a custom timestamp, then this timestamp will be used when the measurement is uploaded securely. This may be a good choice for measurements that take such a long time to establish that using the current task time no longer seems appropriate. A disadvantage of this option is that it becomes harder during analysis to group measurements of different properties that were started at the same.  </p> Example: creating a measurement with a custom timestamp<pre><code>#include &lt;measurements.hpp&gt;\n\nint exampleValue = 1;\ntime_t now = time(nullptr);\n\nMeasurements::Measurement exampleMeasurement(\"example\", exampleValue, now); // (1)!\n</code></pre> <ol> <li>Create a new measurement with property type <code>example</code> and the value  <code>exampleCounter</code> and timestamp <code>now</code>, i.e. the Unix timestamp of the device clock when the code evaluates <code>time(nullptr)</code>.</li> </ol>"},{"location":"measuring/measuring/#adding-a-measurement-to-the-upload-queue","title":"Adding a measurement to the upload queue","text":"<p>The secure upload queue is a queue in volatile memory of the device, to which measurements can be added. Uploading queued measurements is not done immediately, but at a later moment. </p> <p>In order to gain access to the secure upload queue, your measurement task first needs to get an instance of the queue. Each measurement device only has one instance of such a queue, shared by all measurement tasks, which may run in parallel.</p> <p>A measurement can be added to the secure upload queue as shown below:</p> Getting access to the queue and adding a measurement<pre><code>#include &lt;secure_upload.hpp&gt;\n\nauto secureUploadQueue = SecureUpload::Queue::GetInstance();\n\nsecureUploadQueue.AddMeasurement(exampleMeasurement);\n</code></pre>"},{"location":"measuring/running-tasks/","title":"Measurement tasks","text":"<p>The needforheat-generic-firmware library has a scheduler that runs tasks according to a specified interval. The library has some generic tasks that can be started. Your measurement device firmware code can add custom measurement tasks for custom properties.</p>"},{"location":"measuring/running-tasks/#generic-tasks","title":"Generic tasks","text":"<p>The needforheat-generic-firmware library comes with support for the following generic tasks:</p> Task Purpose Default interval Heartbeat Creates a heartbeat measurement and places it on the queue. 10 minutes Battery voltage Measures the battery voltage and places it on the queue. 10 minutes Upload Uploads the contents of the secure upload queue to a NeedForHeat server. 10 minutes Time sync Synchronizes the device clock via NTP 24 hours OTA firmware update Checks for OTA firmware updates and installs them 48 hours Presence detection Sends Bluetooth name requests to specific static MAC addresses and places a response count on the queue. 10 minutes"},{"location":"measuring/running-tasks/#upload-task","title":"Upload task","text":"<p>The upload task uploads all the contents of the secure upload queue to a NeedForHeat server.</p>"},{"location":"measuring/running-tasks/#heartbeat-task","title":"Heartbeat task","text":"<p>The heartbeat task creates a heartbeat measurement and places it on the secure upload queue. The timestamp of a heartbeat and its value are intended to give insight in the basic status of a measurement device. This may be useful for monitoring purposes during a measurement campaign. It also may be useful to get insight in the status of measurement devices during the analysis phase after a measurement campaign.</p>"},{"location":"measuring/running-tasks/#battery-voltage-task","title":"Battery voltage task","text":"<p>The battery voltage measures the closed circuit voltage of the battery of a battery-powered measurement device, such as the M5Stack CoreInk and places it on the secure upload queue.</p>"},{"location":"measuring/running-tasks/#time-sync-task","title":"Time sync task","text":"<p>The time sync tasks synchronizes the system time over the internet using NTP and updates the device clock. It also updates the time on the separate RTC<sup>1</sup> chip, for supported devices that have it,like the M5Stack CoreInk.</p>"},{"location":"measuring/running-tasks/#ota-firmware-update-task","title":"OTA firmware update task","text":"<p>If enabled, the Over The Air (OTA) firmware update task periodically checks for new firmware updates, if enabled. When a new firmware update is found, it will be downloaded and installed. It will then restart once the other tasks are done, and boot the new firmware.</p>"},{"location":"measuring/running-tasks/#presence-detection-task","title":"Presence detection task","text":"<p>If enabled, the presence detection task measures the number of people present nearby via Bluetooth name requests sent to a list of known static MAC-addresses. Such addresses of people's smartphones should only used after obtaining informed consent of each subject involved. </p> <p>For each task time, the total number of unique smartphones that respond to such Bluetooth name requests is counted and this count is placed as a measurement on the secure upload queue. </p> <p>In this way, privacy is respected both for people that gave permission to be counted (no individual information about their presence is sent in measurement values, only aggregate information) as well as other persons that are not participating in your measuremetn campaign as subjects (their smartphones don't even get a Bluetooth name request).</p>"},{"location":"measuring/running-tasks/#starting-generic-tasks","title":"Starting generic tasks","text":"<p>The generic tasks can be added to the scheduler  in the <code>main</code> function of your code:</p> Starting generic tasks<pre><code>#include &lt;generic_tasks.hpp&gt;\n\nextern \"C\" void app_main(void)\n{\n    GenericTasks::AddTasksToScheduler();\n\n    Scheduler::Start(); // (1)!\n}\n</code></pre> <ol> <li><code>AddTasksToScheduler()</code> only adds the generic tasks to the scheduler. They will not run until the scheduler is started.</li> </ol>"},{"location":"measuring/running-tasks/#create-a-custom-measurement-task","title":"Create a custom measurement task","text":"<p>Beside generic tasks, more tasks can be added to the scheduler. In your firmware code you can create custom measurement tasks for properties that your device measures, use the scheduler to make sure your specific measurements are done at specific times.</p>"},{"location":"measuring/running-tasks/#rules","title":"Rules","text":"<p>A NeedForHeat measurement task is freeRTOS task, that adheres to specific rules and for which you need to add specific information that is used by the NeedForHeat scheduler .</p> <p>Any custom NeedForHeat task needs to adhere to these rules:</p> <ol> <li>A task is a function that takes a <code>void *taskInfo</code><sup>2</sup> as a parameter and should not return anything.     The task takes a void pointer and returns nothing<pre><code>void ExampleTask(void *taskInfo /* (1)! */) { ... }\n</code></pre><ol> <li>Use <code>taskInfo</code> here instead of <code>params</code>; these are not the parameters that were passed to the task when adding it to the scheduler.</li> </ol> </li> <li>A task should not contain infinite loops and it must return.</li> <li>The task should be as short as possible. This will maximize the time that the system can sleep and maximize the battery lifetime if your measurement device is powered by batteries.</li> </ol>"},{"location":"measuring/running-tasks/#usage-of-the-scheduler","title":"Usage of the scheduler","text":"<p>The scheduler makes some convenience functions available to any task. If your custom task is added to the scheduler, it can use any of those functions.</p>"},{"location":"measuring/running-tasks/#scheduling-your-custom-task","title":"Scheduling your custom task","text":"<p>When you add your custom task to the scheduler, it will run your task automatically according to a specific interval that you choose:</p> Adding a task to the scheduler<pre><code>#include &lt;scheduler.hpp&gt;\n\nScheduler::AddTask(ExampleTask, // (1)!\n                   \"Example task\", // (2)!\n                   4096, // (3)!\n                   nullptr, // (4)!\n                   1, // (5)!\n                   Scheduler::Interval::MINUTES_10); // (6)!\n</code></pre> <ol> <li>Task function.</li> <li>Task name.</li> <li>Stack size.</li> <li>Parameters passed into task.</li> <li>Priority.</li> <li>Interval.</li> </ol>"},{"location":"measuring/running-tasks/#example-task","title":"Example task","text":"An example task that increments a counter and adds it to the secure upload queue<pre><code>#include &lt;scheduler.hpp&gt;\n#include &lt;measurements.hpp&gt;\n#include &lt;secure_upload.hpp&gt;\n\n// Get access tot the secure upload queue.\nauto secureUploadQueue = SecureUpload::Queue::GetInstance();\n\nvoid ExampleTask(void *taskInfo)\n{\n    // \"example\" is the property name. \n    // \"%d\" is how the value must be formatted.\n    // Formatting happens according to printf formatting rules:\n    // see also https://cplusplus.com/reference/cstdio/printf/\n    Measurements::Measurement::AddFormatter(\"example\", \"%d\");\n\n    static int exampleValue = 0;\n    exampleValue++;\n\n    // Create a new measurement with property type \"example\" \n    // and the value of exampleValue,\n    // formatted according to the printf specifier \"%d\".\n    // Note that in this example, the timestamp is not explicitely specified\n    // so in this case, the secure upload queue will \n    // automatically attach the current task time to this measurement.\n    Measurements::Measurement exampleMeasurement(\"example\", exampleValue);\n\n    // Add the measurement to the queue.\n    secureUploadQueue.AddMeasurement(exampleMeasurement);\n}\n</code></pre> <ol> <li> <p>Real-time clock.\u00a0\u21a9</p> </li> <li> <p>Use <code>taskInfo</code> here instead of <code>params</code>; these are not the parameters that were passed to the task when adding it to the scheduler.\u00a0\u21a9</p> </li> </ol>"},{"location":"measuring/scheduling/","title":"Scheduling","text":"<p>The needforheat-generic-firmware library has a scheduler to which measurement tasks can be added. The scheduler will then run the tasks according to each task's specified interval.</p>"},{"location":"measuring/scheduling/#task-time","title":"Task time","text":"<p>A task time indicates when a round of measurements should be initiated. We only provide support surrently for tasks that start at full minutes, i.e. when the seconds read <code>00</code>. For Unix timestamps, this implies that the timestamp is divisible by 60. </p>"},{"location":"measuring/scheduling/#current-task-time","title":"Current task time","text":"<p>The curent task time is the task time for the current round of measurements. </p>"},{"location":"measuring/scheduling/#next-task-time","title":"Next task time","text":"<p>The next task time is the earliest task time for all upcoming measurements according to their respective measurement intervals. Shortly after all mesurements that were started by the scheduler at the current task time are completed, the remaining time until the next task time is calculated. When using an M5Stack CoreInk, it will turn itself off and restart using its internal RTC<sup>1</sup> when remaining time is more than 2 minutes, to save battery power.</p>"},{"location":"measuring/scheduling/#measurement-intervals","title":"Measurement intervals","text":"<p>The scheduler runs any measurement task with a specified interval. The interval is used in a modulus operation, which means for example, that an interval of 10 minutes will run at minute <code>0, 10, 20, 30, 40 and 50</code> of every hour.</p> <p>The scheduler supports the following intervals:</p> Measurement interval Name 1 minute MINUTES_1 2 minutes MINUTES_2 5 minutes MINUTES_5 10 minutes MINUTES_10 15 minutes MINUTES_15 30 minutes MINUTES_30 1 hour HOURS_1 2 hours HOURS_2 6 hours HOURS_6 12 hours HOURS_12 24 hours HOURS_24 48 hours HOURS_48 1 week WEEKS_1 <p>Using shorter intervals consume more energy and will shorten the run time of battery-operated measuement devices. Some easurement devices can be powered off in between measurement tasks, in order to energy. For such devices, we calsulate a <code>POWER_OFF_THRESHOLD_s</code> value. After all measurements for the current task time are one, if the remaining time until the next task time is below the  <code>POWER_OFF_THRESHOLD_s</code>, such a device will not turn off, since the additional energy required to boot no longer outweighs the saved energy to power off the system. For an M5Stack CoreInk device, this threshold lies betweeen 1 and 2 minutes.</p>"},{"location":"measuring/scheduling/#add-a-task-to-the-scheduler","title":"Add a task to the scheduler","text":"<p>A measurement task can be added to the scheduler as follows:</p> Example: adding a task to the scheduler<pre><code>#include &lt;scheduler.hpp&gt;\n\nScheduler::AddTask(ExampleTask, // (1)!\n                   \"Example task\", // (2)!\n                   4096, // (3)!\n                   nullptr, // (4)!\n                   1, // (5)!\n                   Scheduler::Interval::MINUTES_10); // (6)!\n</code></pre> <ol> <li>Task function.</li> <li>Task name.</li> <li>Stack size.</li> <li>Parameters passed into task.</li> <li>Priority.</li> <li>Interval.</li> </ol>"},{"location":"measuring/scheduling/#start-the-scheduler","title":"Start the scheduler","text":"<p>After all the measurement tasks are added to the scheduler, the scheduler can be started:</p> Example: atarting the scheduler<pre><code>#include &lt;scheduler.hpp&gt;\n\nScheduler::Start();\n</code></pre>"},{"location":"measuring/scheduling/#scheduler-api","title":"Scheduler API","text":"<p>Besides adding a measurement task to the scheduler and starting the scheduler, the scheduler exposes some useful functions that measurement tasks can use.</p>"},{"location":"measuring/scheduling/#schedulergetnametaskinfo","title":"<code>Scheduler::GetName(taskInfo)</code>","text":"<p>This returns a string with the task name given to it when it was added to the scheduler.</p> Example: get the task name from the scheduler<pre><code>#include &lt;scheduler.hpp&gt;\n\nauto taskName = Scheduler::GetName(taskInfo);\nESP_LOGD(taskName.c_str(), \"This is a log message with my task name.\");\n</code></pre>"},{"location":"measuring/scheduling/#schedulergetparamstaskinfo","title":"<code>Scheduler::GetParams(taskInfo)</code>","text":"<p>This returns a void pointer with the parameters that were passed when the task was added to the scheduler.</p> Example: get the task parameters from the scheduler<pre><code>#include &lt;scheduler.hpp&gt;\n\nvoid* params = Scheduler::GetParams(taskInfo);\nint testNumber = (int)params;\n</code></pre>"},{"location":"measuring/scheduling/#schedulergetparamsttaskinfo","title":"<code>Scheduler::GetParams&lt;T&gt;(taskInfo)</code>","text":"<p>This returns a type T with the parameters that were passed when the task was added to the scheduler. No need to cast it yourself.</p> Example: get the task parameters from the scheduler without needing to cast<pre><code>#include &lt;scheduler.hpp&gt;\n\nauto testNumber = Scheduler::GetParams&lt;int&gt;(taskInfo); // (1)!\n</code></pre> <ol> <li><code>testNumber</code> type will be an <code>int</code> since that is the type used in the template parameter of <code>Scheduler::GetParams&lt;T&gt;()</code>.</li> </ol>"},{"location":"measuring/scheduling/#schedulergetidtaskinfo","title":"<code>Scheduler::GetID(taskInfo)</code>","text":"<p>This returns the ID of the task that was automatically given to it by the scheduler.</p> Example: get the task ID from the scheduler<pre><code>#include &lt;scheduler.hpp&gt;\n\nauto id = Scheduler::GetParams&lt;int&gt;(taskInfo);\n</code></pre>"},{"location":"measuring/scheduling/#schedulerwaitforothertaskstaskinfo","title":"<code>Scheduler::WaitForOtherTasks(taskInfo)</code>","text":"<p>This will block the current task until all other tasks are finished.</p> Example: wait for all other tasks to finish<pre><code>#include &lt;scheduler.hpp&gt;\n\nScheduler::WaitForOtherTasks(taskInfo);\n\nESP_LOGD(TAG, \"I am the last task that is running.\"); // (1)!\n</code></pre> <ol> <li>This will only run when the other tasks are finished.</li> </ol> <ol> <li> <p>Real-time clock.\u00a0\u21a9</p> </li> </ol>"},{"location":"measuring/uploading/","title":"Uploading","text":"<p>All queued measurments will be uploaded to a NeedForHeat server via the NeedForHeat API when the upload task runs.</p> <p>In a single upload, one or more measurements for one or more properties can be uploaded. The payload of such an upload is a JSON-formatted string with the following structure:</p> Example: JSON payload of a single heartbeat measurement upload<pre><code>{\n  \"upload_time\": \"1622237550\",\n  \"property_measurements\": [\n    {\n      \"property_name\": \"heartbeat__0\",\n      \"measurements\": [\n        {\n          \"timestamp\": \"1622237550\",\n          \"value\": \"1\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>An upload consists of an <code>upload_time</code>, which indicates the Unix timestamp taken from the device clock of the measurement device just before it uploads the content, followed by array <code>property-measurements</code>, where each element consists of a <code>property_name</code> and an array <code>measurements</code>. Each measurement in this array needs to have a <code>timestamp</code> and a <code>value</code>. </p> <p>Currently, on battery-powerd measurement measurement devices that are completely powered down between measurement tasks, to prevent measurement data loss in the measurement queue, the upload task needs to run after each measurement task. This can be achieved by setting the upload task time equal to the greatest common denominator of all measurement tasks. <p>In a future version of the needforheat-generic-firmware library, we intend to add persistent memory support for the measurement queue. This would allow you to batch the measurement values and upload measurement values in the queue to the server much less often. This can help to extend the run time of battery-powered measurement devices. It also helps make the measurement devices more robust against intermittent loss of internet connectivity.</p>"},{"location":"provisioning/overview/","title":"NeedForHeat provisioning overview","text":"<p>NeedForHeat provisioning is the process that involves:</p> <ul> <li>In a more broad sense:<ul> <li>subject account creation</li> <li>app installation &amp; account activation</li> <li>device preparation </li> </ul> </li> <li>In a more narrow sense:<ul> <li>device installation</li> <li>Wi-Fi provisioning</li> <li>device-app activation</li> <li>device-server activation  </li> </ul> </li> </ul> <p>In a separate pdf document, we provide an overview of needforheat provisioning and the steps and roles played by a NeedForHeat measurement device, app, and API.</p> <p>For a future version of  the needforheat-server-api repository, we consider migrating this seperate pdf document to MkDocs pages like these. Feel free to make a fork and Pull Request for this!</p>"},{"location":"provisioning/testing/","title":"Testing NeedForHeat provisoning","text":"<p>To test NeedForHeat provisioning fully, you should: </p> <ul> <li>use a test instance of the NeedForHeat API connected with a test instance of a NeedForHeat server; </li> <li>compile firmware using swiches that target a test version of the NeedForHeat API connected with a test instance of a NeedForHeat server;</li> <li>prepare a test device;</li> <li>perform device provisioning with a test version of the NeedForHeat WarmteWachter app (see below).</li> </ul> <p>For a future version of the NeedForHeat firmware, API, server and app, we consider allowing the provisioning app to determine whether the (preconfigured) test server URI or production server URI is targeted. </p>"},{"location":"provisioning/testing/#testing-device-provisioning-using-warmtewachter","title":"Testing device provisioning using WarmteWachter","text":"<p>Use a test version of the NeedForHeat WarmteWachter app to test the full NeedForHeat device installation flow, part of which is based on using Espressif Unified Provisioning. </p>"},{"location":"provisioning/testing/#testing-device-provisioning-using-a-unified-provisioning-app","title":"Testing device provisioning using a Unified Provisioning app","text":"<p>Alternatively, you may use test apps that only support Wi-Fi provisioning using Espressif Unified Provisioning; these can be found at:</p> <ul> <li>Android Unified Provisioning app for BLE</li> <li>Android Unified Provisioning app for SoftAP</li> <li>Apple Unified Provisioning app for BLE</li> <li>Apple Unified Provisioning app for SoftAP</li> </ul> <p>Using one of the above Espressif Unified Provisioning apps, you cannot test NeedForHeat device provisioning fully: you can only test the Wi-Fi provisioning part.</p>"},{"location":"releasing/building/","title":"Building firmware","text":"<p>To build firmware for a NeedForHeat measurement device, first open the root folder of the firmware directory in Visual Studio Code.</p>"},{"location":"releasing/building/#building-firmware_1","title":"Building firmware","text":"<ol> <li>Click the PlatformIO Icon (the little alien in the left of the screen).</li> <li>Unfold <code>M5STACK_COREINK</code> when building for M5Stack CoreInk, for other platforms unfold <code>ESP32DEV</code>. <p>Do not use the 'ESP32DEV' environment for M5Stack CoreInk board! It does work, but some features specific to the M5Stack CoreInk will not be included in the firmware, which cause problems during run-time.</p> </li> <li>Click <code>Upload and Monitor</code>.  <p>The first time might take a while because PlatformIO needs to install and build the ESP-IDF before it can upload the firmwware.</p> </li> <li>When it is done uploading, press <code>CTRL+T</code> and then <code>B</code>, then type <code>115200</code> so that it sets the right baud rate and you see text not gibberish.</li> <li>To provision the device, use the NeedForHeat app or another app that supports Espressif Unified Provisioning.</li> </ol>"},{"location":"releasing/releasing/","title":"Releasing firmware","text":"<p>A GitHub repository for NeedForHeat firmware comes with a workflow that automatically initiates actions to build and create a draft for a new release. </p> <p>Such a draft should be verified before it is published. At the time of verifying, a title and description can be added to the release.</p>"},{"location":"releasing/releasing/#semantic-versioning","title":"Semantic versioning","text":"<p>Always use a semantic version number when following the steps below! If you create a tag which is not a semantic version number prepended with \"v\" (e.g. \"v1.0.0\", \"v1.3.12\" or \"v12.34.2\"), Over-The-Air firmare updates will not work properly.</p>"},{"location":"releasing/releasing/#initiating-a-build-and-draft-release","title":"Initiating a build and draft release","text":"<p>Follow the steps below to start the GitHub actions workflow which build the binaries and creates a draf release.</p>"},{"location":"releasing/releasing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Git</li> <li>Git GPG signing (recommended)</li> <li>Singing key secret set up in GitHub Actions</li> </ul>"},{"location":"releasing/releasing/#steps","title":"Steps","text":"<ol> <li>If you have not already cloned the repository, do this now:     <pre><code>git clone https://github.com/energietransitie/needforheat-generic-firmware.git\n</code></pre></li> <li>If you are not already on the main branch, checkout to the main branch:     <pre><code>git checkout main\n</code></pre></li> <li>Make sure your main branch is up-to-date with the remote (typically origin):     <pre><code>git pull origin main\n</code></pre></li> <li>Create a new tag with the new semantic version number:     <pre><code>git tag -s v&lt;semantic version&gt; -m \"&lt;message&gt;\"\n</code></pre>     &gt; The message can contain a description of the tag.</li> <li>Upload the created tag to the remote (typically origin):     <pre><code>git push origin &lt;tag name&gt;\n</code></pre></li> </ol>"},{"location":"releasing/releasing/#publishing","title":"Publishing","text":"<p>This information below only applies to firwmare released by the Research Group Energy Transition.</p> <ol> <li>Go to the releases page.</li> <li>The latest draft release should be at the top of the page. Click on the pen icon in the top right of the release.</li> <li>You can now change the release title and description.</li> <li>The associated tag can be seen. Check if this is correct.</li> <li>The attached binaries can be viewed. Check if these are correct. There should be an archive <code>&lt;repository_name&gt;_&lt;version&gt;.zip</code> and a <code>firmware.bin</code>.</li> <li>Click on <code>Publish release</code> to release the firmware version.</li> </ol>"},{"location":"releasing/secure-boot-bootloader/","title":"Secure bootloader","text":"<p>This section contains information how to build a secure bootloader for NeedForHeat with ESP-IDF. There is anonther page that describes how to build NeedForHeat firmware that uses a secure bootloader. For more general information, you may also want to read the Espressif secure boot documentation.</p> <p>You only need to follow these steps for an ESP32 that does not have secure boot enabled yet, or had its bootloader overwritten.</p>"},{"location":"releasing/secure-boot-bootloader/#prerequisites","title":"Prerequisites","text":"<ul> <li>ESP-IDF installed.</li> </ul>"},{"location":"releasing/secure-boot-bootloader/#build-bootloader","title":"Build bootloader","text":"<p>Use the following command to build the bootloader from the root of the repository: <pre><code>idf.py bootloader -C bootloader/\n</code></pre></p>"},{"location":"releasing/secure-boot-bootloader/#burn-secure-boot-key-to-efuse","title":"Burn secure boot key to eFuse","text":"<p>This only needs to be performed once per ESP32. Use the following command to burn the secure boot key to the eFuse and follow the instructions: <pre><code>espefuse.py burn_key secure_boot_v1 bootloader/build/bootloader/secure-bootloader-key-256.bin\n</code></pre></p>"},{"location":"releasing/secure-boot-bootloader/#flash-bootloader-for-the-first-time","title":"Flash bootloader for the first time","text":"<p>Use the following command to flash the bootloader for the first time: <pre><code>esptool.py --chip esp32 --before=default_reset --after=no_reset write_flash --flash_mode dio --flash_freq 40m --flash_size 4MB 0x1000 bootloader/build/bootloader/bootloader.bin\n</code></pre></p>"},{"location":"releasing/secure-boot-bootloader/#flash-bootloader-after-initial-flash","title":"Flash bootloader after initial flash","text":"<p>Use the following command to flash the bootloader after initial flash: <pre><code>esptool.py --chip esp32 --before=default_reset --after=no_reset write_flash --flash_mode dio --flash_freq 40m --flash_size 4MB 0x0 bootloader/build/bootloader/bootloader-reflash-digest.bin\n</code></pre></p>"},{"location":"releasing/secure-boot-firmware/","title":"Secure boot firmware","text":"<p>This section describes how to sign NeedForHeat firmware to work on an ESP32 with a secure bootloader. There is anonther page that describes how to build and deploy a secure bootloader for NeedForHeat. </p> <p>For more information, see the Espressif secure boot documentation.</p>"},{"location":"releasing/secure-boot-firmware/#prerequisites","title":"Prerequisites","text":"<p>Before signing the firmware, you should first build the firmware.</p>"},{"location":"releasing/secure-boot-firmware/#sign-the-firmware","title":"Sign the firmware","text":"<p>You can use the secure boot signing key of your own organisation to sign the firmware. You need to have the key as a file named <code>secure_boot_signing_key.pem</code> in the root of this repository. Run the following command to sign the firmware: <pre><code>espsecure.py sign_data -v1 --keyfile secure_boot_signing_key.pem --output .pio/build/esp32dev/firmware-signed.bin .pio/build/esp32dev/firmware.bin\n</code></pre></p>"},{"location":"releasing/secure-boot-firmware/#deploy-the-signed-firmware","title":"Deploy the signed firmware","text":"<p>Run the following command to deploy the signed firmware: <pre><code>esptool.py --chip esp32 --baud 460800 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x18000 .pio/build/esp32dev/partitions.bin 0x1d000 .pio/build/esp32dev/ota_data_initial.bin 0x20000 .pio/build/esp32dev/firmware-signed.bin\n</code></pre></p>"},{"location":"releasing/secure-boot-firmware/#github-actions-workflow","title":"GitHub Actions workflow","text":"<p>The GitHub Actions workflow needs a secret with the name <code>SECURE_BOOTLOADER_SIGNING_KEY</code> in order to sign the firmware. This key needs to be set in <code>Settings &gt; Secrets &gt; Actions</code>.</p> <ol> <li>Generate a secure boot signing key:   <pre><code>openssl ecparam -name prime256v1 -genkey -noout -out my_secure_boot_signing_key.pem\n</code></pre> <p>KEEP THIS KEY SAFE!  This key is needed to sign new firmware for a device with secure boot enabled. If this key is lost, no more new firmware can be installed on the device.  Copying this key as a secret for the GitHub Actions workflow will make it available for the build workflow to sign new firmware releases.</p> </li> <li>Copy the contents of the key and paste them as a new secret <code>SECURE_BOOTLOADER_SIGNING_KEY</code> in <code>Settings &gt; Secrets &gt; Actions</code> of the repository.</li> </ol>"},{"location":"starting/devcontainer/","title":"Developing using a Devcontainer","text":"<p>A devcontainer lets you use a Docker container as a development environment. The container has all the necessary depencies installed and can easily be deleted when it is not needed.</p>"},{"location":"starting/devcontainer/#prerequisites","title":"Prerequisites","text":"<p>You will need:</p> <ul> <li>Docker desktop for MacOS or Windows or     Docker for Linux</li> <li>Visual Studio Code</li> <li>Visual Studio Code remote - containers extension</li> </ul>"},{"location":"starting/devcontainer/#build-and-open-the-devcontainer","title":"Build and open the devcontainer","text":"<ol> <li>Open the repository in Visual Studio Code.</li> <li> <p>Click on <code>reopen in container</code> in the popup that will be displayed in the bottom right.</p> <p>The container has to be built the fist time you run it. This process can take around 10-15 minutes, but is largely dependent on your download speed and computer hardware. After building the container the first time, starting it again will be much faster.</p> </li> </ol>"},{"location":"starting/devcontainer/#notes","title":"Notes","text":"<p>This container can be used to build the firmware on any plaftorm (Windows, MacOS or Linux). Windows and MacOS users can not use the devcontainer to deploy binary releases to a device. They should refer to this section to learn how to deploy the firmware.</p> <p>On Linux, the devcontainer can also be used to deploy the firmware to a device. Uncomment the following lines in the <code>\\.devcontainer\\devcontainer.json</code> file to enable this functionality:</p> <pre><code>// Uncommend the 6 lines below to use COM-ports (Linux and MacOS only)\n- // \"mounts\": [\n- //     \"source=/dev,target=/dev,type=bind,consistency=consistent\"\n- // ],\n- // \"runArgs\": [\n- //     \"--privileged\"\n- // ]\n+ \"mounts\": [\n+     \"source=/dev,target=/dev,type=bind,consistency=consistent\"\n+ ],\n+ \"runArgs\": [\n+     \"--privileged\"\n+ ]\n</code></pre>"},{"location":"starting/existing-project/","title":"Integrate with an existing project","text":"<p>For most cases, we recommend to start with a new project. Should you rather integrate the needforheat-generic-firmware library into code for an existing project, read the steps below.</p>"},{"location":"starting/existing-project/#platformio-project","title":"PlatformIO project","text":"<p>The needforheat-generic-firmware library can be added to your PlatformIO project by declaring this repository as a dependency in your <code>platformio.ini</code> file:</p> platformio.ini<pre><code>lib_deps = https://github.com/energietransitie/needforheat-generic-firmware\n</code></pre>"},{"location":"starting/existing-project/#configuration","title":"Configuration","text":"<p>You should also add these lines to your <code>platformio.ini</code> file:</p> platformio.ini<pre><code>;Build and Debug settings:\nbuild_flags = \n    -DCORE_DEBUG_LEVEL=4                ;Uncommented enables debugging\n    -DLOG_LOCAL_LEVEL=4                 ;Uncommented enables debugging\n;   -DCONFIG_NFH_CUSTOM_GPIO         ;Uncommented enables custom GPIO mapping \n    -DCONFIG_NFH_PROV_TRANSPORT_BLE  ; uncomment line to support BLE provisioning\n;   -DCONFIG_NFH_PROV_TRANSPORT_SOFTAP ; uncomment line to support SoftAP provisioning\n;   -DCONFIG_NFH_STRESS_TEST         ;line commented = disabled; line uncommented = enabled\n    -DCONFIG_NFH_PRESENCE_DETECTION  ;line commented = disabled; line uncommented = enabled\n;   -DCONFIG_NFH_PRESENCE_DETECTION_PARALLEL ;line commented = disabled; line uncommented = enabled; keep disabled for now\n    -DCONFIG_NFH_TEST_SERVER         ;line uncommented = use test server; line commented = use other server\n;   -DCONFIG_NFH_PRODUCTION_SERVER   ;line uncommented = use production server; line commented = use other server\n;   -DCONFIG_NFH_OTA_FIRMWARE_UPDATE ;line commented = disabled; line uncommented = enabled\n    -D\"$PIOENV\"\n</code></pre> <p>See <code>platformio.ini</code> for all settings.</p>"},{"location":"starting/new-project/","title":"Use the library in a new project","text":"<p>The easiest way to start a new project for the firmware of your specific measurement device is use the GitHub template NeedForHeat Presence detector, save it to a suitable location and start adding your own code and documentation. This template includes all boilerplate code and configuration files you need.</p>"},{"location":"starting/prerequisites/","title":"Prerequisites for developing","text":"<p>Prerequisites are the prerequisites for deploying, plus:</p> <ul> <li>Visual Studio Code installed</li> <li>PlatformIO for Visual Studio Code installed</li> <li>CMake installed</li> <li>CMake Tools extension for Visual Studio Code installed</li> <li>In Visual Studio Code, open a PlaformIO Command Line Interface and enter     <pre><code>pio platform update\n</code></pre></li> <li>If your user directory name contains a whitespace, you may need to change the platformio.ini file. To avoid the error message \"Error: Detected a whitespace character in project paths\" when building an ESP-IDF project with PlatformIO, add the following lines to the platformio.ini file, as documented in https://docs.platformio.org/en/latest/frameworks/espidf.html#limitations: <pre><code>[platformio]\ncore_dir = &lt;path_without_whitespaces&gt;\n</code></pre></li> <li>This GitHub repository cloned</li> </ul> <p>Refer to developing using a devcontainer  should you prefer that way of developing.</p>"},{"location":"starting/prerequisites/#coding-and-uploading","title":"Coding and uploading","text":"<p>We recommend using a device without secure boot for developing. Follow the steps below to build the firmware and flash it to a device:</p> <ol> <li>In the top-left corner, select File -&gt; Open Folder.</li> <li>Select the folder where you cloned or extracted the repository.</li> <li>Wait for PlatformIO to finish initialization. This step is done until you no longer see \"PlatformIO: Loading tasks...\" in the VS Code status bar.     &gt; \u26a0\ufe0f This step is important! This may take up to \u00b110 minutes. If you do not wait for this to finish, the project will not be able to build correctly.</li> <li>In the <code>src</code> folder you will find <code>main.cpp</code>; this is an example application.</li> <li>In the <code>lib</code> folder you will find the library that this repository contains.</li> <li>To change between provisioning via BLE or SoftAP, in the <code>platformio.ini</code>file, comment the line including <code>-DCONFIG_EXAMPLE_PROV_TRANSPORT_BLE</code> and uncomment the line including <code>-DCONFIG_EXAMPLE_PROV_TRANSPORT_SOFTAP</code> or vice versa.</li> <li>Change the code in <code>src/main.c</code> as you see fit.</li> <li>Build the firmware. See also our documentation on how to build NeedForHeat firmware</li> </ol>"}]}